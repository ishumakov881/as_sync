<templateSet group="_Me_Kotlin">
  <template name="pag" value=" // Пагинация&#10;private var currentPage = 1&#10;val pageSize = 10" description="Pagination" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_EXPRESSION" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="KOTLIN_TOPLEVEL" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="prev2" value="&#10;//================================================================================&#10;// PREVIEW: $FILENAME$&#10;//================================================================================&#10;&#10;@Preview(name = &quot;Phone (Pixel)&quot;, showBackground = true, device = Devices.PIXEL)&#10;@Composable&#10;fun $COMPOSABLE_NAME$_PixelPreview() {&#10;    MaterialTheme {&#10;        $FUN$&#10;    }&#10;}&#10;&#10;@Preview(name = &quot;Phone (360x800 dp)&quot;, showBackground = true, widthDp = 360, heightDp = 800)&#10;@Composable&#10;fun $COMPOSABLE_NAME$_PhonePreview() {&#10;    MaterialTheme {&#10;        $FUN$&#10;    }&#10;}&#10;&#10;@Preview(name = &quot;Tablet (1024x768 dp)&quot;, showBackground = true, widthDp = 1024, heightDp = 768)&#10;@Composable&#10;fun $COMPOSABLE_NAME$_TabletPreview() {&#10;    MaterialTheme {&#10;        $FUN$&#10;    }&#10;}&#10;&#10;@Preview(name = &quot;Landscape&quot;, showBackground = true, widthDp = 500, heightDp = 300)&#10;@Composable&#10;fun $COMPOSABLE_NAME$_LandscapePreview() {&#10;    MaterialTheme {&#10;        $FUN$&#10;    }&#10;}" description="Preview" toReformat="false" toShortenFQNames="true">
    <variable name="FILENAME" expression="fileName()" defaultValue="" alwaysStopAt="false" />
    <variable name="COMPOSABLE_NAME" expression="capitalize(camelCase(fileNameWithoutExtension()))" defaultValue="" alwaysStopAt="false" />
    <variable name="FUN" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_CLASS" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="screens" value="$INPUT$&#10;$SCREENS$&#10;$END$" description="Preview" toReformat="false" toShortenFQNames="true">
    <variable name="INPUT" expression="" defaultValue="ss sss sss sss" alwaysStopAt="true" />
    <variable name="SCREENS" expression="groovyScript(&quot;C\:\\android\\1.groovy&quot;, INPUT)" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_CLASS" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="scrb" value="//ВАЖНО! BackHandler делать тут! т.к глобальный BackHandler перехватывает уже после выполнения bottom навигации&#10;                        BackHandler(drawerState.isOpen || isFullScreen != FullScreen.None) {&#10;                            if (isFullScreen != FullScreen.None) {&#10;                                isFullScreen = FullScreen.None&#10;                            } else if (drawerState.isOpen) {&#10;                                scope.launch {&#10;                                    drawerState.close()&#10;                                }&#10;                            }&#10;                            println(&quot;Back pressed&quot;)&#10;                        }" description="Screen BackHandler" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="state" value="data class $NAME$State(&#10;val isLoading: Boolean = false,&#10;    val isLoadingMore: Boolean = false,&#10;    &#10;    val canLoadMore: Boolean = true, //Флаг, указывающий, можно ли загрузить еще данные&#10;    val currentPage: Int = 1// Пагинация&#10;)&#10;&#10;&#10;class $NAME$ViewModel(&#10;    val repository: PlaybackMediaItemRepository&#10;) : ViewModel() {&#10;&#10;&#10;    &#10;    private val _uiState = MutableStateFlow($NAME$State())&#10;    val uiState: StateFlow&lt;$NAME$State&gt; = _uiState.asStateFlow()&#10;&#10;&#10;    private fun setLoading(isLoading: Boolean) {&#10;        _uiState.update { it.copy(isLoading = isLoading) }&#10;    }&#10;&#10;    private fun setCanLoadMore(canLoadMore: Boolean) {&#10;        _uiState.update { it.copy(canLoadMore = canLoadMore) }&#10;    }&#10;    &#10;    private fun updatePage(page: Int) {&#10;        _uiState.update { it.copy(currentPage = page) }&#10;    }&#10;    &#10;    private fun setLoadingMore(isLoadingMore: Boolean) {&#10;        _uiState.update { it.copy(isLoadingMore = isLoadingMore) }&#10;    }&#10;    &#10;//===================================" description="UI-State ViewModel" toReformat="true" toShortenFQNames="true">
    <variable name="NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="prefset" value="&#10;val PREF_KEY_$PREF_KEY$ = &quot;$NAME$&quot;&#10;&#10;var $NAME$: String&#10;        get() = store.getString(PREF_KEY_$PREF_KEY$, &quot;&quot;)&#10;        set(value) {&#10;            store.putString(PREF_KEY_$PREF_KEY$, value)&#10;        } var token: String&#10;        get() = store.data.first()[SettingsPreferencesKeys.AD_TOKEN] ?: &quot;&quot;&#10;        set(value) {&#10;            store.edit { preferences -&gt;&#10;                preferences[SettingsPreferencesKeys.AD_TOKEN] = value&#10;            }&#10;        }" description="Preference com.russhwolf:multiplatform-settings" toReformat="true" toShortenFQNames="true">
    <variable name="NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="PREF_KEY" expression="capitalizeAndUnderscore(NAME)" defaultValue="NAME 7777" alwaysStopAt="false" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="feedback" value="import android.content.Context&#10;import android.widget.Toast&#10;import androidx.compose.foundation.interaction.MutableInteractionSource&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.Send&#10;import androidx.compose.material.icons.automirrored.outlined.ArrowBack&#10;import androidx.compose.material.icons.automirrored.outlined.Send&#10;import androidx.compose.material.icons.filled.Email&#10;import androidx.compose.material.icons.filled.Forum&#10;import androidx.compose.material.icons.filled.Send&#10;import androidx.compose.material.icons.filled.SendAndArchive&#10;import androidx.compose.material.icons.outlined.ArrowBack&#10;import androidx.compose.material.icons.outlined.Send&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.FloatingActionButton&#10;import androidx.compose.material3.FloatingActionButtonDefaults&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import moe.tlaster.precompose.koin.koinViewModel&#10;import moe.tlaster.precompose.viewmodel.ViewModel&#10;import moe.tlaster.precompose.viewmodel.viewModelScope&#10;&#10;&#10;// 1️⃣ — Состояние экрана&#10;data class $NAME$UiState(&#10;    val message: String = &quot;&quot;,&#10;    val isSending: Boolean = false,&#10;    val error: String? = null,&#10;    val successMessage: String? = null&#10;)&#10;&#10;// 2️⃣ — ViewModel&#10;class $NAME$ViewModel : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow($NAME$UiState())&#10;    val uiState: StateFlow&lt;$NAME$UiState&gt; = _uiState&#10;&#10;    fun onMessageChange(newMessage: String) {&#10;        _uiState.update { it.copy(message = newMessage, error = null) }&#10;    }&#10;&#10;    fun onSendClick(context: Context) {&#10;        val msg = _uiState.value.message.trim()&#10;        if (msg.isBlank()) {&#10;            _uiState.update { it.copy(error = &quot;Сообщение не может быть пустым&quot;) }&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.update { it.copy(isSending = true) }&#10;            try {&#10;                delay(3000)&#10;&#10;//                val intent = Intent(Intent.ACTION_SENDTO).apply {&#10;//                    data = Uri.parse(&quot;mailto:&quot;)&#10;//                    putExtra(Intent.EXTRA_EMAIL, arrayOf(&quot;support@yourapp.com&quot;))&#10;//                    putExtra(Intent.EXTRA_SUBJECT, &quot;Обратная связь&quot;)&#10;//                    putExtra(Intent.EXTRA_TEXT, msg)&#10;//                }&#10;//                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)&#10;//                context.startActivity(intent)&#10;&#10;                _uiState.update {&#10;                    it.copy(&#10;                        isSending = false,&#10;                        successMessage = &quot;Спасибо за сообщение!&quot;,&#10;                        message = &quot;&quot;&#10;                    )&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                _uiState.update {&#10;                    it.copy(isSending = false, error = &quot;Не удалось открыть почтовое приложение&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearSuccess() {&#10;        _uiState.update { it.copy(successMessage = null) }&#10;    }&#10;}&#10;&#10;// 3️⃣ — Контейнерный компонент&#10;@Composable&#10;fun $NAME$Screen(&#10;    viewModel: $NAME$ViewModel = koinViewModel(),&#10;    on$NAME$Sent: () -&gt; Unit&#10;) {&#10;    val uiState by viewModel.uiState.collectAsState()&#10;    val context = LocalContext.current&#10;&#10;    $NAME$ScreenBody(&#10;        state = uiState,&#10;        onMessageChange = viewModel::onMessageChange,&#10;        onSendClick = {&#10;            viewModel.onSendClick(context)&#10;        },&#10;        onBack = {}&#10;    )&#10;&#10;    LaunchedEffect(uiState.successMessage) {&#10;        uiState.successMessage?.let {&#10;            Toast.makeText(context, it, Toast.LENGTH_LONG).show()&#10;            //viewModel.clearState()&#10;            on$NAME$Sent()&#10;        }&#10;    }&#10;}&#10;&#10;// 4️⃣ — UI-компонент (только данные и колбэки)&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun $NAME$ScreenBody(&#10;    state: $NAME$UiState,&#10;    onBack: () -&gt; Unit,&#10;    onMessageChange: (String) -&gt; Unit,&#10;    onSendClick: () -&gt; Unit&#10;) {&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Обратная связь&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Outlined.ArrowBack,&#10;                            contentDescription = &quot;Назад&quot;&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        floatingActionButton = {&#10;            FloatingActionButton(&#10;                onClick = {&#10;                    if (!state.isSending) onSendClick()&#10;                },&#10;                containerColor = if (state.isSending)&#10;                    MaterialTheme.colorScheme.surfaceVariant else FloatingActionButtonDefaults.containerColor,&#10;                elevation = FloatingActionButtonDefaults.elevation()&#10;            ) {&#10;                if (state.isSending) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(20.dp),&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        strokeWidth = 2.dp&#10;                    )&#10;                } else {&#10;                    //Icons.Filled.Forum&#10;                    //Icons.Filled.Email&#10;                    Icon(Icons.AutoMirrored.Filled.Send, contentDescription = &quot;Отправить&quot;)&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(padding)&#10;                .padding(16.dp)&#10;                .fillMaxSize()&#10;        ) {&#10;            OutlinedTextField(&#10;                value = state.message,&#10;                onValueChange = onMessageChange,&#10;                label = { Text(&quot;Ваши пожелания&quot;) },&#10;                placeholder = { Text(&quot;Ваше предложение, проблема или отзыв&quot;) },&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .heightIn(min = 180.dp),&#10;                maxLines = 10,&#10;                singleLine = false&#10;            )&#10;&#10;            if (state.error != null) {&#10;                Text(&#10;                    text = state.error,&#10;                    color = MaterialTheme.colorScheme.error,&#10;                    style = MaterialTheme.typography.bodySmall,&#10;                    modifier = Modifier.padding(top = 8.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;// 5️⃣ — Превью с моковыми данными&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun $NAME$ScreenPreview() {&#10;    $NAME$ScreenBody(&#10;        state = $NAME$UiState(message = &quot;Хочу предложить улучшение...&quot;),&#10;        onBack = {},&#10;        onMessageChange = {},&#10;        onSendClick = {}&#10;    )&#10;}&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun $NAME$ScreenLoadingPreview() {&#10;    $NAME$ScreenBody(&#10;        state = $NAME$UiState(isSending = true),&#10;        onBack = {},&#10;        onMessageChange = {},&#10;        onSendClick = {}&#10;    )&#10;}" description="Screen Feedback" toReformat="true" toShortenFQNames="true">
    <variable name="NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="routes" value="#set($input = ${ROUTES})&#10;#set($routes = $input.split(&quot;,&quot;))&#10;#set($tabRoutes = [&quot;home&quot;, &quot;newmovies&quot;, &quot;test&quot;, &quot;movies&quot;, &quot;series&quot;, &quot;settings&quot;, &quot;devices&quot;])&#10;&#10;sealed class Route(val route: String, val isTabItem: Boolean = true) {&#10;#foreach($r in $routes)&#10;    #set($rTrimmed = $r.trim())&#10;    #set($isTab = $tabRoutes.contains($rTrimmed))&#10;    #set($nameParts = $rTrimmed.split(&quot;_&quot;))&#10;    #set($className = &quot;&quot;)&#10;    #foreach($part in $nameParts)&#10;        #set($className = &quot;${className}${part.substring(0,1).toUpperCase()}${part.substring(1)}&quot;)&#10;    #end&#10;    #if($isTab)&#10;    data object $className : Route(&quot;$rTrimmed&quot;)&#10;    #else&#10;    object $className : Route(&quot;$rTrimmed&quot;, false)&#10;    #end&#10;#end&#10;}&#10;" description="Routes Generator" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
  <template name="ccsc" value="@Composable&#10;fun $SCREEN_NAME$Screen(&#10;    gridColumns: Int = 4,&#10;    onItemClick: ($ITEM_TYPE$) -&gt; Unit,&#10;    onScroll: (isTopBarVisible: Boolean) -&gt; Unit,&#10;    $VIEWMODEL_VAR$: $VIEWMODEL_CLASS$ = koinViewModel($VIEWMODEL_CLASS$::class)&#10;) {&#10;    val uiState by $VIEWMODEL_VAR$.uiState.collectAsState()&#10;    val orientation = LocalConfiguration.current.orientation&#10;&#10;    when (orientation) {&#10;        Configuration.ORIENTATION_PORTRAIT -&gt; $SCREEN_NAME$Portrait(uiState, gridColumns, onItemClick, onScroll)&#10;        Configuration.ORIENTATION_LANDSCAPE -&gt; $SCREEN_NAME$Landscape(uiState, gridColumns, onItemClick, onScroll)&#10;        else -&gt; $SCREEN_NAME$Portrait(uiState, gridColumns, onItemClick, onScroll)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun $SCREEN_NAME$Portrait(&#10;    uiState: $UI_STATE_CLASS$,&#10;    gridColumns: Int,&#10;    onItemClick: ($ITEM_TYPE$) -&gt; Unit,&#10;    onScroll: (Boolean) -&gt; Unit&#10;) {&#10;    when (uiState) {&#10;        $UI_STATE_CLASS$.Loading -&gt; {&#10;            // TODO: Показать лоадер&#10;        }&#10;        is $UI_STATE_CLASS$.Ready -&gt; {&#10;            $SCREEN_NAME$Content(&#10;                gridColumns = gridColumns,&#10;                items = uiState.$DATA_FIELD$,&#10;                onItemClick = onItemClick,&#10;                onScroll = onScroll&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun $SCREEN_NAME$Landscape(&#10;    uiState: $UI_STATE_CLASS$,&#10;    gridColumns: Int,&#10;    onItemClick: ($ITEM_TYPE$) -&gt; Unit,&#10;    onScroll: (Boolean) -&gt; Unit&#10;) {&#10;    when (uiState) {&#10;        $UI_STATE_CLASS$.Loading -&gt; {&#10;            // TODO: Показать лоадер&#10;        }&#10;        is $UI_STATE_CLASS$.Ready -&gt; {&#10;            $SCREEN_NAME$Content(&#10;                gridColumns = gridColumns,&#10;                items = uiState.$DATA_FIELD$,&#10;                onItemClick = onItemClick,&#10;                onScroll = onScroll&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun $SCREEN_NAME$Content(&#10;    gridColumns: Int,&#10;    items: List&lt;$ITEM_TYPE$&gt;,&#10;    onItemClick: ($ITEM_TYPE$) -&gt; Unit,&#10;    onScroll: (Boolean) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // TODO: Верстка с LazyColumn/VerticalGrid&#10;    Catalog(&#10;        gridColumns = gridColumns,&#10;        movieCategories = items,&#10;        onCategoryClick = onItemClick,&#10;        onScroll = onScroll,&#10;        modifier = modifier.fillMaxSize()&#10;    )&#10;}&#10;" description="Screen" toReformat="true" toShortenFQNames="true">
    <variable name="SCREEN_NAME" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="ITEM_TYPE" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="VIEWMODEL_VAR" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="VIEWMODEL_CLASS" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="UI_STATE_CLASS" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="DATA_FIELD" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
      <option name="KOTLIN_COMMENT" value="false" />
      <option name="KOTLIN_OBJECT_DECLARATION" value="false" />
      <option name="KOTLIN_STATEMENT" value="false" />
      <option name="PL/SQL" value="false" />
    </context>
  </template>
</templateSet>